import React, { useState, useEffect, useRef } from 'react'
import { invoke } from '@tauri-apps/api/tauri'
import './App.css'
import GridLayout from './components/GridLayout'
import LayoutConfig from './components/LayoutConfig'
import { LAYOUT_PRESETS, getAllPresets } from './layouts/presets'

function App() {
  const [fixtures, setFixtures] = useState([])
  const [selectedFixtures, setSelectedFixtures] = useState(new Set())
  const [encoderValues, setEncoderValues] = useState({
    dimmer: 0,
    pan: 128,
    tilt: 128,
    red: 0,
    green: 0,
    blue: 0,
  })
  const [faderValues, setFaderValues] = useState(Array(6).fill(0))
  const [artnetConfig, setArtnetConfig] = useState('2.255.255.255')
  const [dmxProtocol, setDmxProtocol] = useState('artnet')
  const [isBlackout, setIsBlackout] = useState(false)
  const [networkInterfaces, setNetworkInterfaces] = useState([])
  const [selectedInterface, setSelectedInterface] = useState(() => {
    const saved = localStorage.getItem('dmx_selected_interface')
    return saved || 'all'
  })
  const [showSetup, setShowSetup] = useState(false)
  const [setupTab, setSetupTab] = useState('artnet') // 'artnet', 'patch', 'gamepad', or 'backup'
  const [gamepadMappings, setGamepadMappings] = useState(() => {
    const saved = localStorage.getItem('dmx_gamepad_mappings')
    return saved ? JSON.parse(saved) : {
      leftTrigger: 'Red',
      rightTrigger: 'Dimmer',
      leftBumper: 'Green',
      rightBumper: 'Blue',
      leftStickX: 'Pan',
      leftStickY: 'Tilt',
      buttonA: 'Select First Fixture',
      buttonB: 'Blackout',
      buttonX: 'Clear Selection',
      buttonY: 'Locate',
      dpadUp: 'Increment',
      dpadDown: 'Decrement',
      dpadLeft: 'Previous Channel',
      dpadRight: 'Next Channel'
    }
  })
  const [incrementSpeed, setIncrementSpeed] = useState('normal') // 'slow' or 'normal'
  const [focusedChannel, setFocusedChannel] = useState(0) // Index of currently focused channel
  const lastDpadPress = useRef({ up: 0, down: 0, left: 0, right: 0 })
  const dpadHoldStart = useRef({ up: 0, down: 0, left: 0, right: 0 })
  const [gamepadDebug, setGamepadDebug] = useState({ connected: false, buttons: [], axes: [] })
  const [showGamepadDebug, setShowGamepadDebug] = useState(true)
  const [savedShows, setSavedShows] = useState([])
  const [newShowName, setNewShowName] = useState('')
  const [recordedCues, setRecordedCues] = useState(() => {
    const saved = localStorage.getItem('dmx_recorded_cues')
    return saved ? JSON.parse(saved) : []
  })
  const [isRecording, setIsRecording] = useState(false)

  // Layout state
  const [currentLayout, setCurrentLayout] = useState(() => {
    const saved = localStorage.getItem('dmx_current_layout')
    return saved ? JSON.parse(saved) : LAYOUT_PRESETS.default
  })
  const [savedLayouts, setSavedLayouts] = useState(() => {
    const saved = localStorage.getItem('dmx_saved_layouts')
    return saved ? JSON.parse(saved) : []
  })
  const [showLayoutConfig, setShowLayoutConfig] = useState(false)
  const [useGridLayout, setUseGridLayout] = useState(() => {
    const saved = localStorage.getItem('dmx_use_grid_layout')
    return saved ? JSON.parse(saved) : true
  })
  const [gridEditMode, setGridEditMode] = useState(false)

  // Refs for gamepad to access current state (fixes closure problem)
  const selectedFixturesRef = useRef(selectedFixtures)
  const fixturesRef = useRef(fixtures)
  const encoderValuesRef = useRef(encoderValues)
  const focusedChannelRef = useRef(focusedChannel)
  const gamepadMappingsRef = useRef(gamepadMappings)
  const incrementSpeedRef = useRef(incrementSpeed)
  const [newFixture, setNewFixture] = useState({
    id: '',
    name: '',
    fixture_type: 'Tree Par',
    dmx_address: 1,
    universe: 0,
    channel_count: 6,
    quantity: 1
  })

  // Fixture profiles with channel definitions
  const fixtureProfiles = {
    'Tree Par': {
      channels: [
        { name: 'Red', offset: 0, type: 'color' },
        { name: 'Green', offset: 1, type: 'color' },
        { name: 'Blue', offset: 2, type: 'color' },
        { name: 'White', offset: 3, type: 'color' },
        { name: 'Amber', offset: 4, type: 'color' },
        { name: 'UV', offset: 5, type: 'color' }
      ],
      count: 6
    },
    'LED PAR': {
      channels: [
        { name: 'Dimmer', offset: 0, type: 'intensity' },
        { name: 'Red', offset: 1, type: 'color' },
        { name: 'Green', offset: 2, type: 'color' },
        { name: 'Blue', offset: 3, type: 'color' },
        { name: 'Pan', offset: 4, type: 'position' },
        { name: 'Tilt', offset: 5, type: 'position' },
        { name: 'Strobe', offset: 6, type: 'effect' }
      ],
      count: 7
    },
    'Moving Head': {
      channels: [
        { name: 'Dimmer', offset: 0, type: 'intensity' },
        { name: 'Red', offset: 1, type: 'color' },
        { name: 'Green', offset: 2, type: 'color' },
        { name: 'Blue', offset: 3, type: 'color' },
        { name: 'Pan', offset: 4, type: 'position' },
        { name: 'Pan Fine', offset: 5, type: 'position' },
        { name: 'Tilt', offset: 6, type: 'position' },
        { name: 'Tilt Fine', offset: 7, type: 'position' },
        { name: 'Strobe', offset: 8, type: 'effect' },
        { name: 'Gobo', offset: 9, type: 'effect' },
        { name: 'Prism', offset: 10, type: 'effect' }
      ],
      count: 16
    },
    'Dimmer': {
      channels: [
        { name: 'Dimmer', offset: 0, type: 'intensity' }
      ],
      count: 1
    }
  }

  // Keep refs in sync with state for gamepad access
  useEffect(() => { selectedFixturesRef.current = selectedFixtures }, [selectedFixtures])
  useEffect(() => { fixturesRef.current = fixtures }, [fixtures])
  useEffect(() => { encoderValuesRef.current = encoderValues }, [encoderValues])
  useEffect(() => { focusedChannelRef.current = focusedChannel }, [focusedChannel])
  useEffect(() => { gamepadMappingsRef.current = gamepadMappings }, [gamepadMappings])
  useEffect(() => { incrementSpeedRef.current = incrementSpeed }, [incrementSpeed])

  // Initialize with no fixtures
  useEffect(() => {
    loadFixtures()
    setupGamepadListener()
    loadSavedShows()
    loadNetworkInterfaces()
  }, [])

  const loadNetworkInterfaces = async () => {
    try {
      const interfaces = await invoke('get_network_interfaces')
      setNetworkInterfaces(interfaces)
    } catch (error) {
      console.error('Error loading network interfaces:', error)
    }
  }

  const loadSavedShows = () => {
    try {
      const stored = localStorage.getItem('dmx_saved_shows')
      if (stored) {
        setSavedShows(JSON.parse(stored))
      }
    } catch (error) {
      console.error('Error loading saved shows:', error)
    }
  }

  const saveShow = () => {
    if (!newShowName.trim()) {
      alert('Please enter a show name')
      return
    }

    const show = {
      name: newShowName,
      timestamp: new Date().toISOString(),
      selectedFixtures: Array.from(selectedFixtures),
      encoderValues: { ...encoderValues },
      faderValues: [...faderValues]
    }

    const updated = [...savedShows.filter(s => s.name !== newShowName), show]
    setSavedShows(updated)
    localStorage.setItem('dmx_saved_shows', JSON.stringify(updated))
    setNewShowName('')
    alert(`Show "${newShowName}" saved successfully!`)
  }

  const recallShow = (show) => {
    setSelectedFixtures(new Set(show.selectedFixtures))
    setEncoderValues(show.encoderValues)
    setFaderValues(show.faderValues)

    // Apply the encoder values to fixtures
    for (const fixtureId of show.selectedFixtures) {
      const fixture = fixtures.find(f => f.id === fixtureId)
      if (!fixture) continue

      const profile = fixtureProfiles[fixture.fixture_type]
      if (!profile) continue

      // Apply all stored encoder values
      Object.entries(show.encoderValues).forEach(async ([param, value]) => {
        const channel = profile.channels.find(ch =>
          ch.name.toLowerCase().replace(/\s+/g, '_') === param
        )
        if (channel) {
          try {
            await invoke('set_fixture_channel', {
              fixtureId,
              channelOffset: channel.offset,
              value: Math.round(value),
            })
          } catch (error) {
            console.error('Error recalling fixture channel:', error)
          }
        }
      })
    }

    alert(`Show "${show.name}" recalled!`)
  }

  const deleteShow = (showName) => {
    if (confirm(`Delete show "${showName}"?`)) {
      const updated = savedShows.filter(s => s.name !== showName)
      setSavedShows(updated)
      localStorage.setItem('dmx_saved_shows', JSON.stringify(updated))
    }
  }

  const loadFixtures = async () => {
    try {
      const loadedFixtures = await invoke('get_fixtures')
      setFixtures(loadedFixtures)
    } catch (error) {
      console.error('Error loading fixtures:', error)
    }
  }

  const toggleFixtureSelection = (fixtureId) => {
    const newSelection = new Set(selectedFixtures)
    if (newSelection.has(fixtureId)) {
      newSelection.delete(fixtureId)
    } else {
      newSelection.add(fixtureId)
    }
    setSelectedFixtures(newSelection)
  }

  const setEncoderValue = async (param, value) => {
    setEncoderValues(prev => ({ ...prev, [param]: value }))

    // Apply to all selected fixtures
    for (const fixtureId of selectedFixtures) {
      try {
        const fixture = fixtures.find(f => f.id === fixtureId)
        if (!fixture) continue

        const profile = fixtureProfiles[fixture.fixture_type]
        if (!profile) continue

        // Find the channel by name
        const channel = profile.channels.find(ch =>
          ch.name.toLowerCase().replace(/\s+/g, '_') === param
        )

        if (channel) {
          await invoke('set_fixture_channel', {
            fixtureId,
            channelOffset: channel.offset,
            value: Math.round(value),
          })
        }
      } catch (error) {
        console.error('Error setting fixture channel:', error)
      }
    }
  }

  const handleBlackout = async () => {
    try {
      await invoke('blackout')
      setIsBlackout(true)
      setTimeout(() => setIsBlackout(false), 300)
    } catch (error) {
      console.error('Error triggering blackout:', error)
    }
  }

  const handleLocate = () => {
    // Set all selected fixtures to full white
    availableChannels.forEach(channel => {
      const channelKey = channel.name.toLowerCase().replace(/\s+/g, '_')
      const nameLower = channel.name.toLowerCase()

      // Set color channels to full
      if (nameLower.includes('red') || nameLower.includes('green') ||
          nameLower.includes('blue') || nameLower.includes('white')) {
        setEncoderValue(channelKey, 255)
      }
      // Set dimmer/intensity to 50%
      else if (nameLower.includes('dimmer') || nameLower.includes('intensity')) {
        setEncoderValue(channelKey, 128)
      }
    })
  }

  const handleClear = () => {
    // Just clear selection, not all parameters
    setSelectedFixtures(new Set())
  }

  const handleClearAll = () => {
    // Clear everything - selection and all parameters
    setSelectedFixtures(new Set())
    setEncoderValues({
      dimmer: 0,
      pan: 128,
      tilt: 128,
      red: 0,
      green: 0,
      blue: 0,
    })
  }

  const applyColorPalette = (color) => {
    // Find and set RGB channels if they exist
    const findAndSetChannel = (name, value) => {
      const channel = availableChannels.find(ch =>
        ch.name.toLowerCase().includes(name.toLowerCase())
      )
      if (channel) {
        const channelKey = channel.name.toLowerCase().replace(/\s+/g, '_')
        setEncoderValue(channelKey, value)
      }
    }

    findAndSetChannel('red', color.r)
    findAndSetChannel('green', color.g)
    findAndSetChannel('blue', color.b)
  }

  // Get available channels for selected fixtures
  const getAvailableChannels = () => {
    if (selectedFixtures.size === 0) {
      return []
    }

    // Get all selected fixtures
    const selectedFixturesList = fixtures.filter(f => selectedFixtures.has(f.id))

    if (selectedFixturesList.length === 0) {
      return []
    }

    // Find common channels across all selected fixtures
    const firstFixture = selectedFixturesList[0]
    const firstProfile = fixtureProfiles[firstFixture.fixture_type]

    if (!firstProfile) {
      return []
    }

    // Start with channels from first fixture
    const commonChannels = firstProfile.channels.filter(channel => {
      // Check if this channel exists in all other selected fixtures
      return selectedFixturesList.every(fixture => {
        const profile = fixtureProfiles[fixture.fixture_type]
        return profile && profile.channels.some(ch => ch.name === channel.name)
      })
    })

    return commonChannels
  }

  const availableChannels = getAvailableChannels()

  const handleArtnetConfig = async () => {
    try {
      await invoke('configure_artnet', { broadcastAddress: artnetConfig })
      await invoke('set_protocol', { protocol: dmxProtocol })

      // Set network interface
      const interfaceIp = selectedInterface === 'all' ? null : selectedInterface
      await invoke('set_network_interface', { interfaceIp })

      // Save to localStorage
      localStorage.setItem('dmx_selected_interface', selectedInterface)

      alert(`Protocol set to ${dmxProtocol.toUpperCase()} with broadcast: ${artnetConfig}\nInterface: ${selectedInterface === 'all' ? 'All interfaces' : selectedInterface}`)
    } catch (error) {
      console.error('Error configuring network:', error)
      alert('Error configuring network: ' + error)
    }
  }

  const handleAddFixture = async () => {
    if (!newFixture.id || !newFixture.name) {
      alert('Please fill in fixture ID and name')
      return
    }

    const quantity = parseInt(newFixture.quantity) || 1

    try {
      // Add multiple fixtures with auto-incrementing addresses
      for (let i = 0; i < quantity; i++) {
        const fixtureToAdd = {
          id: quantity > 1 ? `${newFixture.id}${i + 1}` : newFixture.id,
          name: quantity > 1 ? `${newFixture.name} ${i + 1}` : newFixture.name,
          fixture_type: newFixture.fixture_type,
          dmx_address: newFixture.dmx_address + (i * newFixture.channel_count),
          universe: newFixture.universe,
          channel_count: newFixture.channel_count
        }
        await invoke('add_fixture', { fixture: fixtureToAdd })
      }

      await loadFixtures()
      setNewFixture({
        id: '',
        name: '',
        fixture_type: 'Tree Par',
        dmx_address: 1,
        universe: 0,
        channel_count: 6,
        quantity: 1
      })

      if (quantity > 1) {
        alert(`${quantity} fixtures added successfully!`)
      } else {
        alert(`Fixture ${newFixture.name} added successfully!`)
      }
    } catch (error) {
      console.error('Error adding fixture:', error)
      alert('Error adding fixture: ' + error)
    }
  }

  const handleDeleteFixture = async (fixtureId) => {
    if (confirm(`Delete fixture ${fixtureId}?`)) {
      // Note: Backend doesn't have delete yet, just remove from state
      setFixtures(fixtures.filter(f => f.id !== fixtureId))
      setSelectedFixtures(prev => {
        const newSet = new Set(prev)
        newSet.delete(fixtureId)
        return newSet
      })
    }
  }

  // Record a cue
  const handleRecordCue = () => {
    if (selectedFixtures.size === 0) {
      alert('Select fixtures before recording a cue')
      return
    }

    const cueName = prompt(`Enter cue name (Cue ${recordedCues.length + 1}):`, `Cue ${recordedCues.length + 1}`)
    if (!cueName) return

    const newCue = {
      name: cueName,
      timestamp: Date.now(),
      selectedFixtures: Array.from(selectedFixtures),
      encoderValues: { ...encoderValues },
      faderValues: [...faderValues]
    }

    const updated = [...recordedCues, newCue]
    setRecordedCues(updated)
    localStorage.setItem('dmx_recorded_cues', JSON.stringify(updated))

    setIsRecording(true)
    setTimeout(() => setIsRecording(false), 500) // Flash record indicator
    alert(`Cue "${cueName}" recorded!`)
  }

  // Recall a cue
  const handleRecallCue = (cue) => {
    // Restore selection
    setSelectedFixtures(new Set(cue.selectedFixtures))

    // Restore encoder values
    setEncoderValues(cue.encoderValues)
    Object.entries(cue.encoderValues).forEach(([key, value]) => {
      setEncoderValue(key, value)
    })

    // Restore fader values
    setFaderValues(cue.faderValues)
  }

  // Delete a cue
  const handleDeleteCue = (cueName) => {
    const updated = recordedCues.filter(c => c.name !== cueName)
    setRecordedCues(updated)
    localStorage.setItem('dmx_recorded_cues', JSON.stringify(updated))
  }

  // Execute gamepad action based on mapping
  const executeGamepadAction = (actionName) => {
    const fixtures = fixturesRef.current
    const selected = selectedFixturesRef.current

    switch (actionName) {
      case 'Select First Fixture':
        if (fixtures.length > 0) {
          toggleFixtureSelection(fixtures[0].id)
        }
        break
      case 'Blackout':
        handleBlackout()
        break
      case 'Clear Selection':
        handleClear()
        break
      case 'Locate':
        handleLocate()
        break
      case 'Record Cue':
        handleRecordCue()
        break
      case 'Previous Fixture':
        if (fixtures.length > 0 && selected.size > 0) {
          const selectedArray = Array.from(selected)
          const currentId = selectedArray[0]
          const currentIndex = fixtures.findIndex(f => f.id === currentId)
          if (currentIndex > 0) {
            setSelectedFixtures(new Set([fixtures[currentIndex - 1].id]))
          }
        }
        break
      case 'Next Fixture':
        if (fixtures.length > 0 && selected.size > 0) {
          const selectedArray = Array.from(selected)
          const currentId = selectedArray[0]
          const currentIndex = fixtures.findIndex(f => f.id === currentId)
          if (currentIndex < fixtures.length - 1) {
            setSelectedFixtures(new Set([fixtures[currentIndex + 1].id]))
          }
        }
        break
      case 'Select All':
        setSelectedFixtures(new Set(fixtures.map(f => f.id)))
        break
      case 'Clear All':
        handleClear()
        setEncoderValues({
          dimmer: 0,
          pan: 128,
          tilt: 128,
          red: 0,
          green: 0,
          blue: 0,
        })
        break
      case 'None':
        // Do nothing
        break
      default:
        break
    }
  }

  const setupGamepadListener = () => {
    // Steam Deck gamepad support
    let gamepadIndex = null
    const lastButtonPress = { time: 0, button: -1 }
    const buttonDebounceTime = 300 // milliseconds
    let lastDebugUpdate = 0
    const debugUpdateInterval = 100 // Update debug display every 100ms instead of every frame

    const pollGamepad = () => {
      const gamepads = navigator.getGamepads()

      for (let i = 0; i < gamepads.length; i++) {
        if (gamepads[i]) {
          gamepadIndex = i
          const gamepad = gamepads[i]

          // Update debug info (throttled to prevent crashes)
          const now = Date.now()
          if (now - lastDebugUpdate > debugUpdateInterval) {
            lastDebugUpdate = now
            setGamepadDebug({
              connected: true,
              buttons: gamepad.buttons.map((btn, idx) => ({ index: idx, pressed: btn.pressed, value: btn.value })),
              axes: gamepad.axes.map((val, idx) => ({ index: idx, value: val }))
            })
          }

          // Get fresh available channels using refs (fixes closure problem)
          const getCurrentAvailableChannels = () => {
            if (selectedFixturesRef.current.size === 0) {
              return []
            }
            const selectedFixturesList = fixturesRef.current.filter(f => selectedFixturesRef.current.has(f.id))
            if (selectedFixturesList.length === 0) {
              return []
            }
            const firstFixture = selectedFixturesList[0]
            const firstProfile = fixtureProfiles[firstFixture.fixture_type]
            if (!firstProfile) {
              return []
            }
            return firstProfile.channels.filter(channel => {
              return selectedFixturesList.every(fixture => {
                const profile = fixtureProfiles[fixture.fixture_type]
                return profile && profile.channels.some(ch => ch.name === channel.name)
              })
            })
          }

          const currentAvailableChannels = getCurrentAvailableChannels()

          // Map gamepad controls to available channels using mappings
          const findChannel = (mappedName) => {
            if (!mappedName || mappedName === 'None') return null
            return currentAvailableChannels.find(ch =>
              ch.name.toLowerCase().includes(mappedName.toLowerCase())
            )
          }

          // Left trigger (L2)
          const leftTriggerChannel = findChannel(gamepadMappingsRef.current.leftTrigger)
          if (leftTriggerChannel && gamepad.buttons[6].value > 0.1) {
            const channelKey = leftTriggerChannel.name.toLowerCase().replace(/\s+/g, '_')
            setEncoderValue(channelKey, gamepad.buttons[6].value * 255)
          }

          // Right trigger (R2)
          const rightTriggerChannel = findChannel(gamepadMappingsRef.current.rightTrigger)
          if (rightTriggerChannel && gamepad.buttons[7].value > 0.1) {
            const channelKey = rightTriggerChannel.name.toLowerCase().replace(/\s+/g, '_')
            setEncoderValue(channelKey, gamepad.buttons[7].value * 255)
          }

          // Left bumper (L1)
          const leftBumperChannel = findChannel(gamepadMappingsRef.current.leftBumper)
          if (leftBumperChannel && gamepad.buttons[4].value > 0.1) {
            const channelKey = leftBumperChannel.name.toLowerCase().replace(/\s+/g, '_')
            setEncoderValue(channelKey, gamepad.buttons[4].value * 255)
          }

          // Right bumper (R1)
          const rightBumperChannel = findChannel(gamepadMappingsRef.current.rightBumper)
          if (rightBumperChannel && gamepad.buttons[5].value > 0.1) {
            const channelKey = rightBumperChannel.name.toLowerCase().replace(/\s+/g, '_')
            setEncoderValue(channelKey, gamepad.buttons[5].value * 255)
          }

          // Left Joystick
          const leftStickXChannel = findChannel(gamepadMappingsRef.current.leftStickX)
          const leftStickYChannel = findChannel(gamepadMappingsRef.current.leftStickY)

          if (leftStickXChannel && Math.abs(gamepad.axes[0]) > 0.1) {
            const channelKey = leftStickXChannel.name.toLowerCase().replace(/\s+/g, '_')
            setEncoderValue(channelKey, (gamepad.axes[0] + 1) * 127.5)
          }
          if (leftStickYChannel && Math.abs(gamepad.axes[1]) > 0.1) {
            const channelKey = leftStickYChannel.name.toLowerCase().replace(/\s+/g, '_')
            setEncoderValue(channelKey, (gamepad.axes[1] + 1) * 127.5)
          }

          // D-Pad controls with acceleration and wrap-around
          const dpadDebounceTime = 150 // milliseconds for initial press
          const dpadAccelerationThreshold = 500 // ms to hold before acceleration kicks in

          // Calculate increment based on hold duration (acceleration)
          const getAcceleratedIncrement = (holdDuration) => {
            const baseIncrement = incrementSpeedRef.current === 'slow' ? 1 : 5
            if (holdDuration < dpadAccelerationThreshold) {
              return baseIncrement
            } else if (holdDuration < 1000) {
              return baseIncrement * 2
            } else if (holdDuration < 2000) {
              return baseIncrement * 4
            } else {
              return baseIncrement * 8
            }
          }

          // D-Pad Up (button 12) - Increment focused channel
          if (gamepad.buttons[12] && gamepad.buttons[12].pressed) {
            if (currentAvailableChannels.length > 0) {
              // Track when button was first pressed
              if (dpadHoldStart.current.up === 0) {
                dpadHoldStart.current.up = now
              }

              const holdDuration = now - dpadHoldStart.current.up

              if (now - lastDpadPress.current.up > dpadDebounceTime) {
                lastDpadPress.current.up = now
                const channel = currentAvailableChannels[focusedChannelRef.current]
                const channelKey = channel.name.toLowerCase().replace(/\s+/g, '_')
                const currentValue = encoderValuesRef.current[channelKey] || 0
                const increment = getAcceleratedIncrement(holdDuration)
                const newValue = Math.min(255, currentValue + increment)
                setEncoderValue(channelKey, newValue)
              }
            }
          } else {
            dpadHoldStart.current.up = 0
          }

          // D-Pad Down (button 13) - Decrement focused channel
          if (gamepad.buttons[13] && gamepad.buttons[13].pressed) {
            if (currentAvailableChannels.length > 0) {
              if (dpadHoldStart.current.down === 0) {
                dpadHoldStart.current.down = now
              }

              const holdDuration = now - dpadHoldStart.current.down

              if (now - lastDpadPress.current.down > dpadDebounceTime) {
                lastDpadPress.current.down = now
                const channel = currentAvailableChannels[focusedChannelRef.current]
                const channelKey = channel.name.toLowerCase().replace(/\s+/g, '_')
                const currentValue = encoderValuesRef.current[channelKey] || 0
                const decrement = getAcceleratedIncrement(holdDuration)
                const newValue = Math.max(0, currentValue - decrement)
                setEncoderValue(channelKey, newValue)
              }
            }
          } else {
            dpadHoldStart.current.down = 0
          }

          // D-Pad Left (button 14) - Previous channel (with wrap-around)
          if (gamepad.buttons[14] && gamepad.buttons[14].pressed) {
            if (currentAvailableChannels.length > 0 && now - lastDpadPress.current.left > dpadDebounceTime) {
              lastDpadPress.current.left = now
              setFocusedChannel(prev => {
                const newIndex = prev - 1
                return newIndex < 0 ? currentAvailableChannels.length - 1 : newIndex
              })
            }
          }

          // D-Pad Right (button 15) - Next channel (with wrap-around)
          if (gamepad.buttons[15] && gamepad.buttons[15].pressed) {
            if (currentAvailableChannels.length > 0 && now - lastDpadPress.current.right > dpadDebounceTime) {
              lastDpadPress.current.right = now
              setFocusedChannel(prev => {
                const newIndex = prev + 1
                return newIndex >= currentAvailableChannels.length ? 0 : newIndex
              })
            }
          }

          // A button (button 0) - Mapped action
          if (gamepad.buttons[0] && gamepad.buttons[0].pressed) {
            if (now - lastButtonPress.time > buttonDebounceTime || lastButtonPress.button !== 0) {
              lastButtonPress.time = now
              lastButtonPress.button = 0
              executeGamepadAction(gamepadMappingsRef.current.buttonA)
            }
          }

          // B button (button 1) - Mapped action
          if (gamepad.buttons[1] && gamepad.buttons[1].pressed) {
            if (now - lastButtonPress.time > buttonDebounceTime || lastButtonPress.button !== 1) {
              lastButtonPress.time = now
              lastButtonPress.button = 1
              executeGamepadAction(gamepadMappingsRef.current.buttonB)
            }
          }

          // X button (button 2) - Mapped action
          if (gamepad.buttons[2] && gamepad.buttons[2].pressed) {
            if (now - lastButtonPress.time > buttonDebounceTime || lastButtonPress.button !== 2) {
              lastButtonPress.time = now
              lastButtonPress.button = 2
              executeGamepadAction(gamepadMappingsRef.current.buttonX)
            }
          }

          // Y button (button 3) - Mapped action
          if (gamepad.buttons[3] && gamepad.buttons[3].pressed) {
            if (now - lastButtonPress.time > buttonDebounceTime || lastButtonPress.button !== 3) {
              lastButtonPress.time = now
              lastButtonPress.button = 3
              executeGamepadAction(gamepadMappingsRef.current.buttonY)
            }
          }
        }
      }

      requestAnimationFrame(pollGamepad)
    }

    // Check for gamepad connection
    window.addEventListener('gamepadconnected', (e) => {
      console.log('Gamepad connected:', e.gamepad.id)
      pollGamepad()
    })

    // Start polling if gamepad already connected
    const gamepads = navigator.getGamepads()
    if (gamepads[0]) {
      pollGamepad()
    }
  }

  // Layout management functions
  const saveLayout = (layout) => {
    setCurrentLayout(layout)
    localStorage.setItem('dmx_current_layout', JSON.stringify(layout))

    // Also save to saved layouts if it has a name
    if (layout.name && layout.name.trim()) {
      const updated = [...savedLayouts.filter(l => l.name !== layout.name), layout]
      setSavedLayouts(updated)
      localStorage.setItem('dmx_saved_layouts', JSON.stringify(updated))
    }
  }

  const handleLayoutChange = (newLayout) => {
    setCurrentLayout(newLayout)
    localStorage.setItem('dmx_current_layout', JSON.stringify(newLayout))
  }

  const loadLayoutPreset = (presetName) => {
    const preset = LAYOUT_PRESETS[presetName]
    if (preset) {
      setCurrentLayout(preset)
      localStorage.setItem('dmx_current_layout', JSON.stringify(preset))
    }
  }

  const deleteLayout = (layoutName) => {
    const updated = savedLayouts.filter(l => l.name !== layoutName)
    setSavedLayouts(updated)
    localStorage.setItem('dmx_saved_layouts', JSON.stringify(updated))
  }

  const toggleGridLayout = () => {
    const newValue = !useGridLayout
    setUseGridLayout(newValue)
    localStorage.setItem('dmx_use_grid_layout', JSON.stringify(newValue))
  }

  const colorPalettes = [
    { name: 'Red', r: 255, g: 0, b: 0 },
    { name: 'Green', r: 0, g: 255, b: 0 },
    { name: 'Blue', r: 0, g: 0, b: 255 },
    { name: 'White', r: 255, g: 255, b: 255 },
    { name: 'Cyan', r: 0, g: 255, b: 255 },
    { name: 'Magenta', r: 255, g: 0, b: 255 },
    { name: 'Yellow', r: 255, g: 255, b: 0 },
    { name: 'Orange', r: 255, g: 128, b: 0 },
    { name: 'Pink', r: 255, g: 128, b: 192 },
  ]

  // Prepare app state for views
  const appState = {
    fixtures,
    selectedFixtures,
    toggleFixtureSelection,
    encoderValues,
    setEncoderValue,
    focusedChannel,
    setFocusedChannel,
    availableChannels,
    applyColorPalette,
    faderValues,
    setFaderValues,
    handleBlackout,
    handleLocate,
    handleClear,
    handleRecordCue,
    isRecording,
    recordedCues,
    handleRecallCue,
    handleDeleteCue
  }

  return (
    <div className="app-container">
      {/* Top Bar - MA dot2 style */}
      <div className="top-bar">
        <div className="top-bar-left">
          <div className="top-bar-title">DMX Control</div>
          <button className="top-bar-button" onClick={loadFixtures}>
            Refresh
          </button>
          <button className="top-bar-button" onClick={() => { setSetupTab('patch'); setShowSetup(true); }}>
            Patch
          </button>
          <button className="top-bar-button" onClick={() => { setSetupTab('backup'); setShowSetup(true); }}>
            Backup
          </button>
          <button className="top-bar-button" onClick={() => { setSetupTab('artnet'); setShowSetup(true); }}>
            Setup
          </button>
          <button
            className={`top-bar-button ${useGridLayout ? 'active' : ''}`}
            onClick={() => setShowLayoutConfig(true)}
            title="Configure Layout"
          >
            üìê Layout
          </button>
          <button
            className="top-bar-button"
            onClick={toggleGridLayout}
            title="Toggle Grid Layout"
          >
            {useGridLayout ? 'üî≤' : 'üìã'}
          </button>
          {useGridLayout && (
            <button
              className={`top-bar-button ${gridEditMode ? 'active' : ''}`}
              onClick={() => setGridEditMode(!gridEditMode)}
              title="Toggle Edit Mode (right-click to change views, drag to move, click handles to resize)"
            >
              ‚úèÔ∏è Edit
            </button>
          )}
        </div>
        <div className="top-bar-right">
          <span style={{ fontSize: '11px', color: '#888', marginRight: '10px' }}>
            {currentLayout.name}
          </span>
          <span style={{ fontSize: '12px', color: '#666' }}>
            {dmxProtocol.toUpperCase()}: {artnetConfig}
          </span>
        </div>
      </div>

      {/* Main Content */}
      <div className="main-content" style={{ height: useGridLayout ? 'calc(100vh - 100px)' : 'auto' }}>
        {useGridLayout ? (
          <GridLayout
            layout={currentLayout}
            appState={appState}
            onLayoutChange={handleLayoutChange}
            editMode={gridEditMode}
          />
        ) : (
          <>
        {/* Left Panel - Fixtures */}
        <div className="fixture-panel">
          <div className="panel-title">Fixtures</div>
          <div className="fixture-grid">
            {fixtures.map((fixture) => (
              <div
                key={fixture.id}
                className={`fixture-item ${selectedFixtures.has(fixture.id) ? 'selected' : ''}`}
                onClick={() => toggleFixtureSelection(fixture.id)}
              >
                <div className="fixture-number">{fixture.id}</div>
                <div className="fixture-name">{fixture.name}</div>
                <div style={{ fontSize: '9px', opacity: 0.6 }}>
                  U{fixture.universe}:{fixture.dmx_address}
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Center - Programmer */}
        <div className="programmer-section">
          <div className="panel-title">
            Programmer - {selectedFixtures.size} Fixture{selectedFixtures.size !== 1 ? 's' : ''} Selected
          </div>
          <div className="encoder-grid">
            {selectedFixtures.size === 0 ? (
              <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '40px', color: '#666' }}>
                Select fixtures to see available controls
              </div>
            ) : availableChannels.length === 0 ? (
              <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '40px', color: '#666' }}>
                No common channels found
              </div>
            ) : (
              availableChannels.map((channel, index) => {
                const channelKey = channel.name.toLowerCase().replace(/\s+/g, '_')
                const value = encoderValues[channelKey] || 0
                const isFocused = index === focusedChannel

                // Determine color based on channel type and name
                const getChannelColor = (name) => {
                  const nameLower = name.toLowerCase()
                  if (nameLower.includes('red')) return '#ff0000'
                  if (nameLower.includes('green')) return '#00ff00'
                  if (nameLower.includes('blue')) return '#0088ff'
                  if (nameLower.includes('white')) return '#ffffff'
                  if (nameLower.includes('amber')) return '#ffbf00'
                  if (nameLower.includes('uv')) return '#8b00ff'
                  if (nameLower.includes('cyan')) return '#00ffff'
                  if (nameLower.includes('magenta')) return '#ff00ff'
                  if (nameLower.includes('yellow')) return '#ffff00'
                  return null
                }

                const channelColor = getChannelColor(channel.name)

                return (
                  <div
                    key={channelKey}
                    className="encoder"
                    style={isFocused ? {
                      outline: '2px solid #4a9eff',
                      outlineOffset: '2px',
                      borderRadius: '4px',
                      background: 'rgba(74, 158, 255, 0.1)'
                    } : {}}
                  >
                    <div className="encoder-label">
                      {channel.name}
                      {isFocused && <span style={{marginLeft: '5px', color: '#4a9eff'}}>‚óÑ</span>}
                    </div>
                    <div
                      className="encoder-wheel"
                      onClick={() => {
                        setFocusedChannel(index)
                        const newVal = (value + 25.5) % 255
                        setEncoderValue(channelKey, newVal)
                      }}
                    >
                      <div
                        className="encoder-value"
                        style={channelColor ? { color: channelColor } : {}}
                      >
                        {Math.round(value)}
                      </div>
                      <div
                        className="encoder-indicator"
                        style={{
                          transform: `rotate(${(value / 255) * 270 - 135}deg)`,
                          ...(channelColor ? { background: channelColor } : {})
                        }}
                      />
                    </div>
                  </div>
                )
              })
            )}
          </div>
        </div>

        {/* Right Panel - Palettes */}
        <div className="palette-panel">
          <div className="panel-title">Color Palettes</div>
          <div className="palette-grid">
            {colorPalettes.map((palette) => (
              <div
                key={palette.name}
                className="palette-button"
                onClick={() => applyColorPalette(palette)}
              >
                <div
                  className="palette-color"
                  style={{
                    background: `rgb(${palette.r}, ${palette.g}, ${palette.b})`,
                  }}
                />
                <div className="palette-label">{palette.name}</div>
              </div>
            ))}
          </div>
        </div>

        {/* Bottom - Executor Faders */}
        <div className="executor-section">
          <div className="executor-faders">
            {faderValues.map((value, index) => (
              <div key={index} className="fader">
                <div
                  className="fader-track"
                  onClick={(e) => {
                    const rect = e.currentTarget.getBoundingClientRect()
                    const y = rect.bottom - e.clientY
                    const percentage = Math.max(0, Math.min(1, y / rect.height))
                    const newFaderValues = [...faderValues]
                    newFaderValues[index] = percentage * 255
                    setFaderValues(newFaderValues)
                  }}
                >
                  <div
                    className="fader-handle"
                    style={{ bottom: `${(value / 255) * 100}%` }}
                  />
                </div>
                <div className="fader-label">
                  Exec {index + 1}
                  <br />
                  {Math.round(value)}
                </div>
              </div>
            ))}
          </div>
        </div>
          </>
        )}
      </div>

      {/* Quick Action Buttons - Only show when not using grid layout */}
      {!useGridLayout && (
        <>
          <div className="quick-actions">
            <button className="action-button blackout" onClick={handleBlackout}>
              Black
            </button>
            <button className="action-button locate" onClick={handleLocate}>
              Locate
            </button>
            <button className="action-button clear" onClick={handleClear}>
              Clear
            </button>
          </div>

          {/* Gamepad Hints */}
          <div className="gamepad-hint">
            üéÆ Steam Deck: D-Pad=Navigate/Adjust Channels (hold for speed) | L2=Red | L1=Green | R1=Blue | R2=Dimmer | A=Select | B=Blackout | X=Clear | Y=Locate
          </div>
        </>
      )}

      {/* Gamepad Debug Display */}
      {showGamepadDebug && (
        <div style={{
          position: 'fixed',
          bottom: '40px',
          right: '10px',
          background: 'rgba(0, 0, 0, 0.9)',
          color: '#0f0',
          padding: '10px',
          fontSize: '10px',
          fontFamily: 'monospace',
          maxWidth: '400px',
          maxHeight: '300px',
          overflow: 'auto',
          zIndex: 999,
          borderRadius: '4px',
          border: '1px solid #0f0'
        }}>
          <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
            <strong>GAMEPAD DEBUG</strong>
            <button onClick={() => setShowGamepadDebug(false)} style={{background: 'none', border: 'none', color: '#0f0', cursor: 'pointer'}}>‚úï</button>
          </div>
          <div>Status: {gamepadDebug.connected ? 'CONNECTED' : 'DISCONNECTED'}</div>
          <div style={{marginTop: '5px'}}>
            <strong>Buttons:</strong>
            <div style={{display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '2px', marginTop: '2px'}}>
              {gamepadDebug.buttons.map(btn => (
                <div key={btn.index} style={{
                  background: btn.pressed ? '#0f0' : '#333',
                  color: btn.pressed ? '#000' : '#0f0',
                  padding: '2px',
                  textAlign: 'center',
                  fontSize: '9px'
                }}>
                  {btn.index}: {btn.value.toFixed(2)}
                </div>
              ))}
            </div>
          </div>
          <div style={{marginTop: '5px'}}>
            <strong>Axes:</strong>
            {gamepadDebug.axes.map(axis => (
              <div key={axis.index}>Axis {axis.index}: {axis.value.toFixed(3)}</div>
            ))}
          </div>
        </div>
      )}

      {/* Setup Modal */}
      {showSetup && (
        <div className="modal-overlay" onClick={() => setShowSetup(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h2>
                {setupTab === 'artnet' ? 'Network Configuration' :
                 setupTab === 'patch' ? 'Patch Fixtures' :
                 setupTab === 'backup' ? 'Show Backup & Recall' :
                 'Gamepad Mapping'}
              </h2>
              <button className="modal-close" onClick={() => setShowSetup(false)}>‚úï</button>
            </div>

            <div className="modal-tabs">
              <button
                className={`modal-tab ${setupTab === 'artnet' ? 'active' : ''}`}
                onClick={() => setSetupTab('artnet')}
              >
                Network
              </button>
              <button
                className={`modal-tab ${setupTab === 'patch' ? 'active' : ''}`}
                onClick={() => setSetupTab('patch')}
              >
                Patch
              </button>
              <button
                className={`modal-tab ${setupTab === 'backup' ? 'active' : ''}`}
                onClick={() => setSetupTab('backup')}
              >
                Backup
              </button>
              <button
                className={`modal-tab ${setupTab === 'gamepad' ? 'active' : ''}`}
                onClick={() => setSetupTab('gamepad')}
              >
                Gamepad
              </button>
            </div>

            <div className="modal-body">
              {setupTab === 'artnet' ? (
                <div className="setup-section">
                  <h3>Network Configuration</h3>
                  <div className="form-group">
                    <label>DMX Protocol:</label>
                    <select
                      value={dmxProtocol}
                      onChange={(e) => setDmxProtocol(e.target.value)}
                    >
                      <option value="artnet">Art-Net</option>
                      <option value="sacn">sACN (E1.31)</option>
                    </select>
                  </div>
                  <div className="form-group">
                    <label>Broadcast Address:</label>
                    <input
                      type="text"
                      value={artnetConfig}
                      onChange={(e) => setArtnetConfig(e.target.value)}
                      placeholder="2.255.255.255"
                    />
                  </div>
                  <div className="form-group">
                    <label>Network Interface:</label>
                    <select
                      value={selectedInterface}
                      onChange={(e) => setSelectedInterface(e.target.value)}
                    >
                      <option value="all">All Interfaces (0.0.0.0)</option>
                      {networkInterfaces.map((iface) => (
                        <option key={iface.ip} value={iface.ip}>
                          {iface.name} - {iface.ip}
                          {iface.is_loopback ? ' (loopback)' : ''}
                        </option>
                      ))}
                    </select>
                  </div>
                  <div className="form-help">
                    <p><strong>Network Interface:</strong></p>
                    <ul>
                      <li><strong>All Interfaces (0.0.0.0)</strong> - Send DMX on all network interfaces</li>
                      <li><strong>Specific Interface</strong> - Send DMX only on selected WiFi/Ethernet adapter</li>
                      <li>Choose the interface connected to your lighting network</li>
                      <li>Loopback (127.x.x.x) is only for testing</li>
                    </ul>
                    <br/>
                    <p><strong>Art-Net configurations:</strong></p>
                    <ul>
                      <li><code>2.255.255.255</code> - Standard Art-Net broadcast</li>
                      <li><code>10.255.255.255</code> - Class A private network</li>
                      <li><code>192.168.1.255</code> - Class C private network</li>
                    </ul>
                    <p>Port: <code>6454</code> (UDP)</p>
                    <br/>
                    <p><strong>sACN (E1.31):</strong></p>
                    <ul>
                      <li>Multicast: <code>239.255.0.x</code> (auto-configured)</li>
                      <li>Unicast: Use specific device IP</li>
                      <li>Port: <code>5568</code> (UDP)</li>
                    </ul>
                  </div>
                  <button className="btn-primary" onClick={handleArtnetConfig}>
                    Apply Network Configuration
                  </button>
                </div>
              ) : setupTab === 'patch' ? (
                <div className="setup-section">
                  <h3>Add New Fixture</h3>
                  <div className="form-grid">
                    <div className="form-group">
                      <label>Fixture ID:</label>
                      <input
                        type="text"
                        value={newFixture.id}
                        onChange={(e) => setNewFixture({...newFixture, id: e.target.value})}
                        placeholder="fx7"
                      />
                    </div>
                    <div className="form-group">
                      <label>Fixture Name:</label>
                      <input
                        type="text"
                        value={newFixture.name}
                        onChange={(e) => setNewFixture({...newFixture, name: e.target.value})}
                        placeholder="Wash 5"
                      />
                    </div>
                    <div className="form-group">
                      <label>Type:</label>
                      <select
                        value={newFixture.fixture_type}
                        onChange={(e) => {
                          const profile = fixtureProfiles[e.target.value]
                          setNewFixture({
                            ...newFixture,
                            fixture_type: e.target.value,
                            channel_count: profile ? profile.count : 1
                          })
                        }}
                      >
                        {Object.keys(fixtureProfiles).map(profileName => (
                          <option key={profileName}>{profileName}</option>
                        ))}
                      </select>
                    </div>
                    <div className="form-group">
                      <label>Universe:</label>
                      <input
                        type="number"
                        value={newFixture.universe}
                        onChange={(e) => setNewFixture({...newFixture, universe: parseInt(e.target.value)})}
                        min="0" max="255"
                      />
                    </div>
                    <div className="form-group">
                      <label>DMX Address:</label>
                      <input
                        type="number"
                        value={newFixture.dmx_address}
                        onChange={(e) => setNewFixture({...newFixture, dmx_address: parseInt(e.target.value)})}
                        min="1" max="512"
                      />
                    </div>
                    <div className="form-group">
                      <label>Channel Count:</label>
                      <input
                        type="number"
                        value={newFixture.channel_count}
                        onChange={(e) => setNewFixture({...newFixture, channel_count: parseInt(e.target.value)})}
                        min="1" max="32"
                      />
                    </div>
                    <div className="form-group">
                      <label>Quantity:</label>
                      <input
                        type="number"
                        value={newFixture.quantity}
                        onChange={(e) => setNewFixture({...newFixture, quantity: parseInt(e.target.value)})}
                        min="1" max="100"
                        placeholder="1"
                      />
                    </div>
                  </div>
                  {newFixture.quantity > 1 && (
                    <div className="form-help" style={{marginTop: '-10px'}}>
                      <p><strong>Batch Add:</strong> Will create {newFixture.quantity} fixtures:</p>
                      <ul>
                        <li>IDs: {newFixture.id}1, {newFixture.id}2, {newFixture.id}3...</li>
                        <li>Names: {newFixture.name} 1, {newFixture.name} 2, {newFixture.name} 3...</li>
                        <li>Addresses: {newFixture.dmx_address}, {newFixture.dmx_address + newFixture.channel_count}, {newFixture.dmx_address + (newFixture.channel_count * 2)}...</li>
                      </ul>
                    </div>
                  )}
                  <div style={{marginTop: '5px'}}></div>
                  {fixtureProfiles[newFixture.fixture_type] && (
                    <div className="form-help">
                      <p><strong>Channel Layout for {newFixture.fixture_type}:</strong></p>
                      <ul>
                        {fixtureProfiles[newFixture.fixture_type].channels.map((ch, idx) => (
                          <li key={idx}>Ch {ch.offset + 1}: {ch.name} ({ch.type})</li>
                        ))}
                      </ul>
                      <p>Total: {fixtureProfiles[newFixture.fixture_type].count} channels</p>
                    </div>
                  )}

                  <button className="btn-primary" onClick={handleAddFixture}>
                    Add Fixture
                  </button>

                  <h3 style={{ marginTop: '30px' }}>Current Fixtures</h3>
                  <div className="fixture-list">
                    {fixtures.map((fixture) => (
                      <div key={fixture.id} className="fixture-list-item">
                        <div>
                          <strong>{fixture.name}</strong> ({fixture.id})
                          <br />
                          <small>{fixture.fixture_type} - U{fixture.universe}:{fixture.dmx_address} - {fixture.channel_count}ch</small>
                        </div>
                        <button
                          className="btn-delete"
                          onClick={() => handleDeleteFixture(fixture.id)}
                        >
                          Delete
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
              ) : setupTab === 'gamepad' ? (
                <div className="setup-section">
                  <h3>Steam Input Configuration</h3>
                  <div className="form-help" style={{marginBottom: '25px'}}>
                    <p><strong>Using Steam Deck Controls:</strong></p>
                    <ul>
                      <li>This app works natively with Steam Input - no special configuration needed!</li>
                      <li>When added to Steam as a non-Steam game, configure controls in Steam's controller settings</li>
                      <li>Recommended: Set Steam Input to "Gamepad" template for best compatibility</li>
                      <li>The app uses browser Gamepad API which works seamlessly with Steam Input</li>
                      <li>You can customize button layouts in Steam's per-game controller configuration</li>
                    </ul>
                  </div>

                  <h3>Button Mapping</h3>
                  <p style={{color: '#aaa', fontSize: '13px', marginBottom: '20px'}}>
                    Map gamepad buttons to functions. Changes are saved automatically.
                  </p>

                  <div className="form-grid" style={{gridTemplateColumns: 'repeat(2, 1fr)'}}>
                    <div className="form-group">
                      <label>A Button:</label>
                      <select
                        value={gamepadMappings.buttonA}
                        onChange={(e) => {
                          const newMappings = {...gamepadMappings, buttonA: e.target.value}
                          setGamepadMappings(newMappings)
                          localStorage.setItem('dmx_gamepad_mappings', JSON.stringify(newMappings))
                        }}
                      >
                        <option>None</option>
                        <option>Select First Fixture</option>
                        <option>Previous Fixture</option>
                        <option>Next Fixture</option>
                        <option>Select All</option>
                        <option>Clear Selection</option>
                        <option>Blackout</option>
                        <option>Locate</option>
                        <option>Clear All</option>
                        <option>Record Cue</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>B Button:</label>
                      <select
                        value={gamepadMappings.buttonB}
                        onChange={(e) => {
                          const newMappings = {...gamepadMappings, buttonB: e.target.value}
                          setGamepadMappings(newMappings)
                          localStorage.setItem('dmx_gamepad_mappings', JSON.stringify(newMappings))
                        }}
                      >
                        <option>None</option>
                        <option>Select First Fixture</option>
                        <option>Previous Fixture</option>
                        <option>Next Fixture</option>
                        <option>Select All</option>
                        <option>Clear Selection</option>
                        <option>Blackout</option>
                        <option>Locate</option>
                        <option>Clear All</option>
                        <option>Record Cue</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>X Button:</label>
                      <select
                        value={gamepadMappings.buttonX}
                        onChange={(e) => {
                          const newMappings = {...gamepadMappings, buttonX: e.target.value}
                          setGamepadMappings(newMappings)
                          localStorage.setItem('dmx_gamepad_mappings', JSON.stringify(newMappings))
                        }}
                      >
                        <option>None</option>
                        <option>Select First Fixture</option>
                        <option>Previous Fixture</option>
                        <option>Next Fixture</option>
                        <option>Select All</option>
                        <option>Clear Selection</option>
                        <option>Blackout</option>
                        <option>Locate</option>
                        <option>Clear All</option>
                        <option>Record Cue</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>Y Button:</label>
                      <select
                        value={gamepadMappings.buttonY}
                        onChange={(e) => {
                          const newMappings = {...gamepadMappings, buttonY: e.target.value}
                          setGamepadMappings(newMappings)
                          localStorage.setItem('dmx_gamepad_mappings', JSON.stringify(newMappings))
                        }}
                      >
                        <option>None</option>
                        <option>Select First Fixture</option>
                        <option>Previous Fixture</option>
                        <option>Next Fixture</option>
                        <option>Select All</option>
                        <option>Clear Selection</option>
                        <option>Blackout</option>
                        <option>Locate</option>
                        <option>Clear All</option>
                        <option>Record Cue</option>
                      </select>
                    </div>
                  </div>

                  <h3 style={{marginTop: '30px'}}>Trigger & Bumper Mapping</h3>
                  <p style={{color: '#aaa', fontSize: '13px', marginBottom: '20px'}}>
                    Map triggers and bumpers to fixture attributes. Controls will only work when fixtures with matching attributes are selected.
                  </p>

                  <div className="form-grid" style={{gridTemplateColumns: 'repeat(2, 1fr)'}}>
                    <div className="form-group">
                      <label>L2 (Left Trigger):</label>
                      <select
                        value={gamepadMappings.leftTrigger}
                        onChange={(e) => setGamepadMappings({...gamepadMappings, leftTrigger: e.target.value})}
                      >
                        <option>None</option>
                        <option>Red</option>
                        <option>Green</option>
                        <option>Blue</option>
                        <option>White</option>
                        <option>Amber</option>
                        <option>UV</option>
                        <option>Dimmer</option>
                        <option>Intensity</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>R2 (Right Trigger):</label>
                      <select
                        value={gamepadMappings.rightTrigger}
                        onChange={(e) => setGamepadMappings({...gamepadMappings, rightTrigger: e.target.value})}
                      >
                        <option>None</option>
                        <option>Red</option>
                        <option>Green</option>
                        <option>Blue</option>
                        <option>White</option>
                        <option>Amber</option>
                        <option>UV</option>
                        <option>Dimmer</option>
                        <option>Intensity</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>L1 (Left Bumper):</label>
                      <select
                        value={gamepadMappings.leftBumper}
                        onChange={(e) => setGamepadMappings({...gamepadMappings, leftBumper: e.target.value})}
                      >
                        <option>None</option>
                        <option>Red</option>
                        <option>Green</option>
                        <option>Blue</option>
                        <option>White</option>
                        <option>Amber</option>
                        <option>UV</option>
                        <option>Dimmer</option>
                        <option>Intensity</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>R1 (Right Bumper):</label>
                      <select
                        value={gamepadMappings.rightBumper}
                        onChange={(e) => setGamepadMappings({...gamepadMappings, rightBumper: e.target.value})}
                      >
                        <option>None</option>
                        <option>Red</option>
                        <option>Green</option>
                        <option>Blue</option>
                        <option>White</option>
                        <option>Amber</option>
                        <option>UV</option>
                        <option>Dimmer</option>
                        <option>Intensity</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>Left Stick X-Axis:</label>
                      <select
                        value={gamepadMappings.leftStickX}
                        onChange={(e) => setGamepadMappings({...gamepadMappings, leftStickX: e.target.value})}
                      >
                        <option>None</option>
                        <option>Pan</option>
                        <option>Tilt</option>
                        <option>Red</option>
                        <option>Green</option>
                        <option>Blue</option>
                      </select>
                    </div>

                    <div className="form-group">
                      <label>Left Stick Y-Axis:</label>
                      <select
                        value={gamepadMappings.leftStickY}
                        onChange={(e) => setGamepadMappings({...gamepadMappings, leftStickY: e.target.value})}
                      >
                        <option>None</option>
                        <option>Pan</option>
                        <option>Tilt</option>
                        <option>Red</option>
                        <option>Green</option>
                        <option>Blue</option>
                      </select>
                    </div>
                  </div>

                  <h3 style={{marginTop: '25px'}}>D-Pad Increment/Decrement Speed</h3>
                  <div className="form-group">
                    <label>D-Pad Speed:</label>
                    <select
                      value={incrementSpeed}
                      onChange={(e) => setIncrementSpeed(e.target.value)}
                    >
                      <option value="slow">Slow (¬±1 per press)</option>
                      <option value="normal">Normal (¬±5 per press)</option>
                    </select>
                  </div>
                  <div className="form-help">
                    <p><strong>D-Pad Controls:</strong></p>
                    <ul>
                      <li><strong>D-Pad Up</strong>: Increment focused channel value</li>
                      <li><strong>D-Pad Down</strong>: Decrement focused channel value</li>
                      <li><strong>D-Pad Left</strong>: Select previous channel (wraps around)</li>
                      <li><strong>D-Pad Right</strong>: Select next channel (wraps around)</li>
                    </ul>
                    <p style={{marginTop: '10px'}}>
                      <strong>Pro Tip:</strong> Hold Up/Down longer for acceleration! Speed increases at 0.5s, 1s, and 2s.
                      The currently focused channel will be highlighted in the Programmer section.
                    </p>
                  </div>

                  <div className="form-help">
                    <p><strong>Current Mapping:</strong></p>
                    <ul>
                      <li><strong>L2</strong>: {gamepadMappings.leftTrigger || 'None'}</li>
                      <li><strong>L1</strong>: {gamepadMappings.leftBumper || 'None'}</li>
                      <li><strong>R1</strong>: {gamepadMappings.rightBumper || 'None'}</li>
                      <li><strong>R2</strong>: {gamepadMappings.rightTrigger || 'None'}</li>
                      <li><strong>Left Stick</strong>: X={gamepadMappings.leftStickX || 'None'}, Y={gamepadMappings.leftStickY || 'None'}</li>
                    </ul>
                    <p style={{marginTop: '10px', fontSize: '12px'}}>
                      <strong>Note:</strong> Mappings are case-insensitive and will match any channel with the selected name.
                      Fixed buttons: A=Select Fixture 1, B=Blackout, X=Clear Selection, Y=Locate
                    </p>
                  </div>
                </div>
              ) : setupTab === 'backup' ? (
                <div className="setup-section">
                  <h3>Save Current Show</h3>
                  <div className="form-group">
                    <label>Show Name:</label>
                    <input
                      type="text"
                      value={newShowName}
                      onChange={(e) => setNewShowName(e.target.value)}
                      placeholder="My Awesome Show"
                      onKeyPress={(e) => {
                        if (e.key === 'Enter') {
                          saveShow()
                        }
                      }}
                    />
                  </div>
                  <div className="form-help">
                    <p>Current state to save:</p>
                    <ul>
                      <li><strong>{selectedFixtures.size}</strong> fixture{selectedFixtures.size !== 1 ? 's' : ''} selected</li>
                      <li><strong>{Object.keys(encoderValues).filter(k => encoderValues[k] > 0).length}</strong> encoder values set</li>
                      <li><strong>{faderValues.filter(v => v > 0).length}</strong> faders active</li>
                    </ul>
                  </div>
                  <button className="btn-primary" onClick={saveShow}>
                    Save Show
                  </button>

                  <h3 style={{ marginTop: '30px' }}>Saved Shows ({savedShows.length})</h3>
                  {savedShows.length === 0 ? (
                    <p style={{ color: '#666', fontStyle: 'italic' }}>No saved shows yet. Create one above!</p>
                  ) : (
                    <div className="fixture-list">
                      {savedShows.map((show) => (
                        <div key={show.name} className="fixture-list-item">
                          <div>
                            <strong>{show.name}</strong>
                            <br />
                            <small style={{ color: '#888' }}>
                              {show.selectedFixtures.length} fixture{show.selectedFixtures.length !== 1 ? 's' : ''} ‚Ä¢
                              Saved {new Date(show.timestamp).toLocaleString()}
                            </small>
                          </div>
                          <div style={{ display: 'flex', gap: '10px' }}>
                            <button
                              className="btn-primary"
                              onClick={() => recallShow(show)}
                              style={{ fontSize: '12px', padding: '5px 15px' }}
                            >
                              Recall
                            </button>
                            <button
                              className="btn-delete"
                              onClick={() => deleteShow(show.name)}
                            >
                              Delete
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}

                  <div className="form-help" style={{ marginTop: '30px' }}>
                    <p><strong>About Show Backup:</strong></p>
                    <ul>
                      <li>Saves all selected fixtures and their current values</li>
                      <li>Includes encoder settings and fader positions</li>
                      <li>Shows are stored in browser localStorage</li>
                      <li>Recall instantly restores the entire show state</li>
                      <li>Perfect for saving looks, scenes, or entire setlists</li>
                    </ul>
                  </div>
                </div>
              ) : null}
            </div>
          </div>
        </div>
      )}

      {/* Layout Configuration Modal */}
      {showLayoutConfig && (
        <LayoutConfig
          layout={currentLayout}
          onSave={saveLayout}
          onClose={() => setShowLayoutConfig(false)}
          savedLayouts={[...savedLayouts, ...getAllPresets()]}
          onLoadLayout={(layout) => {
            setCurrentLayout(layout)
            localStorage.setItem('dmx_current_layout', JSON.stringify(layout))
          }}
          onDeleteLayout={deleteLayout}
        />
      )}
    </div>
  )
}

export default App
